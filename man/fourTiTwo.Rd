% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/4ti2.R
\name{basis}
\alias{basis}
\alias{graver}
\alias{groebner}
\alias{hilbert}
\alias{markov}
\alias{memZbasis}
\alias{mem_graver}
\alias{mem_groebner}
\alias{mem_hilbert}
\alias{mem_markov}
\alias{mem_zsolve}
\alias{zbasis}
\alias{zsolve}
\title{Compute a basis with 4ti2}
\usage{
basis(exec)

zsolve(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), opts = defaultOpts, quiet = TRUE, dbName = NULL)

zbasis(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), opts = defaultOpts, quiet = TRUE, dbName = NULL)

markov(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), opts = defaultOpts, quiet = TRUE, dbName = NULL)

groebner(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), opts = defaultOpts, quiet = TRUE, dbName = NULL)

hilbert(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), opts = defaultOpts, quiet = TRUE, dbName = NULL)

graver(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), opts = defaultOpts, quiet = TRUE, dbName = NULL)

mem_zsolve(...)

memZbasis(...)

mem_markov(...)

mem_groebner(...)

mem_hilbert(...)

mem_graver(...)
}
\arguments{
\item{exec}{(temporary, don't use)}

\item{A}{a matrix}

\item{format}{how the basis (moves) should be returned.  if
"mat", the moves are returned as the columns of a matrix.}

\item{dim}{the dimension to be passed to \code{\link{vec2tab}} if
format = "tab" is used; a vector of the number of levels of
each variable in order}

\item{all}{if TRUE, all moves (+ and -) are given.  if FALSE,
only the + moves are given as returned by the executable.}

\item{dir}{directory to place the files in, without an ending /}

\item{opts}{options for basis ("-parb" for markov, zbasis, and
groebner; "" for graver)}

\item{quiet}{if FALSE, messages the 4ti2 output}

\item{dbName}{the name of the model in the markov bases database,
http://markov-bases.de, see examples}

\item{...}{...}
}
\value{
a matrix containing the Markov basis as its columns (for
  easy addition to tables)
}
\description{
4ti2 provides several executables that can be used to generate
bases for a configuration matrix A.  See the references for
details.
}
\examples{

\dontrun{ these examples require having 4ti2 installed




# basic input and output for the 2x2 independence example
(A <- rbind(
  kprod(diag(3), ones_r(3)),
  kprod(ones_r(3), diag(3))
))
markov(A)
markov(A, "vec")
markov(A, "tab", c(3, 3))
markov(A, "tab", c(3, 3), all = TRUE)
tableau(markov(A), dim = c(3, 3)) # tableau notation




# a slighly larger example, 2x3 independence)
# (source: LAS ex 1.2.1, p.12)
(A <- rbind(
  kprod(diag(2), ones_r(3)),
  kprod(ones_r(2), diag(3))
))

markov(A, "tab", c(3, 3))
# Prop 1.2.2 says that there should be
2*choose(2, 2)*choose(3,2) # = 6
# moves (up to +-1)
markov(A, "tab", c(3, 3), TRUE)




# comparing the bases for the 3x3x3 no-three-way interaction model
A <- rbind(
  kprod(  diag(3),   diag(3), ones_r(3)),
  kprod(  diag(3), ones_r(3),   diag(3)),
  kprod(ones_r(3),   diag(3),   diag(3))
)
str(zbasis(A))   #    8 elements = ncol(A) - qr(A)$rank
str(markov(A))   #   81 elements
str(groebner(A)) #  110 elements
str(graver(A))   #  795 elements



# you can memoise the result; this will cache the result for
# future use.  (note that it doesn't persist across sessions.)
A <- rbind(
  kprod(  diag(4), ones_r(4), ones_r(4)),
  kprod(ones_r(4),   diag(4), ones_r(4)),
  kprod(ones_r(4), ones_r(4),   diag(4))
)
system.time(markov(A))
system.time(markov(A))
system.time(mem_markov(A))
system.time(mem_markov(A))

A <- rbind(
  kprod(  diag(3), ones_r(3), ones_r(2)),
  kprod(ones_r(3),   diag(3), ones_r(2)),
  kprod(ones_r(3), ones_r(3),   diag(2))
)
system.time(graver(A))
system.time(mem_graver(A))
system.time(mem_graver(A))









# LAS example 1.2.12, p.17  (no 3-way interaction)
(A <- rbind(
  kprod(  diag(2),   diag(2), ones_r(2)),
  kprod(  diag(2), ones_r(2),   diag(2)),
  kprod(ones_r(2),   diag(2),   diag(2))
))
markov(A)
tableau(markov(A), dim = c(2,2,2))



# LAS example 1.2.12, p.16  (no 3-way interaction)
A <- rbind(
  kprod(  diag(2),   diag(2),  ones_r(2), ones_r(2)),
  kprod(  diag(2), ones_r(2),  ones_r(2),   diag(2)),
  kprod(ones_r(2),   diag(2),    diag(2), ones_r(2))
)
plot_matrix(A)
zbasis(A)
markov(A)
groebner(A)
graver(A)









# using the markov bases database, must be connected to internet
# A <- markov(dbName = "ind3-3")
B <- markov(rbind(
  kprod(diag(3), ones_r(3)),
  kprod(ones_r(3), diag(3))
))
# all(A == B)












markov(diag(1, 10))
zbasis(diag(1, 10), "vec")
groebner(diag(1, 10), "vec", all = TRUE)
graver(diag(1, 10), "vec", all = TRUE)
graver(diag(1, 4), "tab", all = TRUE, dim = c(2,2))

}


}
\references{
Drton, M., B. Sturmfels, and S. Sullivant (2009).
  \emph{Lectures on Algebraic Statistics}, Basel: Birkhauser
  Verlag AG.
}

